#' Analyze a chess game.
#'
#' Chess games are analyzed using a UCI compatible chess engine.
#'
#' @details The rbitr package relies on the
#'   [bigchess](https://github.com/rosawojciech/bigchess) package to handle the
#'   interfaces to
#'   [Universal Chess Interface (UCI)](http://wbec-ridderkerk.nl/html/UCIProtocol.html)
#'   compatible chess engines. To use `analyze_game()`, an engine handler must
#'   first be created with the bigchess `uci_engine()` function, and the handler
#'   must then be passed to `analyze_game()` (see example).
#'
#' @details The game to be analyzed should be in a pgn-compatible format, that
#'   is, moves should be in standard algebraic notation (SAN) and any comments,
#'   annotations, or variations should comply with the
#'   [pgn specification](http://www.saremba.de/chessgml/standards/pgn/pgn-complete.htm).
#'   If variations are present, they will not be analyzed. The game is passed
#'   into the function as a single-element character vector via the movetext
#'   parameter. The movetext is typically obtained via `get_pgn()`, where it
#'   would be found in the $Movetext column of that function's output.
#'
#' @details The number of principal variations to be analyzed is set using the
#'   n_pv parameter, while the depth of analysis (in plies) is set by the depth
#'   parameter. Both parameters are required, and must be positive integers.
#'
#' @param movetext A single-element character vector containing a sequence of
#'   moves in standard algebraic notation (SAN).
#' @param engine An engine handler generated by the
#'   [bigchess](https://github.com/rosawojciech/bigchess) function
#'   `uci_engine()`.
#' @param n_pv A single-element integer vector of the desired number of
#'   principal variations.
#' @param depth A single-element integer vector of the desired search depth, in
#'   plies.
#'
#' @return A list containing character vectors of the engine output. Each
#'   element in the list corresponds to a position in the game, beginning with
#'   the initial position before any move has been made.
#' @export
#'
#' @examples
#' library(bigchess)
#' movetext <- '1. e4 g5 2. Nc3 f5 3. Qh5# 1-0'
#' # Modify engine_path as required for your engine location & operating system
#' engine_path <- '//stockfish_13_win_x64_bmi2.exe'
#' engine <- uci_engine(engine_path)
#' rbitr::analyze_game(movetext, engine, n_pv = 1, depth = 1)
analyze_game <- function(movetext, engine, n_pv, depth) {
  # Validate the input
  assertthat::assert_that(assertthat::is.string(movetext))
  assertthat::assert_that(class(engine$pipe)[1] == 'process')
  assertthat::assert_that(assertthat::is.count(n_pv))
  assertthat::assert_that(assertthat::is.count(depth))
  # Convert the game to a machine readable format
  moves <- clean_movetext(movetext)
  moves <- bigchess::san2lan(moves)
  moves <- unlist(strsplit(moves, split = ' '), use.names = FALSE)
  moves <- c('', moves)
  # Set up the engine
  pv_command <- paste0('setoption name MultiPV value ', n_pv)
  engine <- bigchess::uci_cmd(engine, command = pv_command)
  engine <- bigchess::uci_ucinewgame(engine)
  engine <- bigchess::uci_isready(engine)
  engine <- bigchess::uci_position(engine)
  # Analyze the game
  analyze_move <- function(move_index, moves, engine, depth) {
    moves <- paste0(moves[1:move_index], collapse = ' ')
    move_command <- paste0('position startpos moves ', moves)
    engine <- bigchess::uci_cmd(engine, command = move_command)
    engine <- bigchess::uci_go(engine, depth = depth)
    bigchess::uci_read(engine)$temp
  }
  move_index <- 1:length(moves)
  lapply(move_index, analyze_move, moves = moves, engine = engine, depth = depth)
}
